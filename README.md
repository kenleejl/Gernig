# Gernig

## Basic Usage

The following example shows how to add noise via the Python interface:

```python
from gernig import Noiser
from gernig.modules import *

n = Noiser("program64.exe")  # Initialize with target binary

n.addNoise(PrintNoise("Hello world!"))  # Add PrintNoise module
n.addNoise(DnsNoise("google.com"))  # Add DnsNoise module

n.generate("output.exe")

```

Run the generated binary:

```
.\output.exe
```

## Development Setup

### Prerequisites

- [MinGW-w64 multilib](https://sourceforge.net/projects/mingw-w64/files/Toolchains%20targetting%20Win64/Personal%20Builds/mingw-builds/8.1.0/threads-posix/sjlj/x86_64-8.1.0-release-posix-sjlj-rt_v6-rev0.7z/download)
- [GnuWin Make](http://gnuwin32.sourceforge.net/downlinks/make.php)
- Python 3

## Gernig Development

- `loader32/64.exe` - Main program that will dispatch noise modules as threads and load the target binary from memory
- `program32/64.exe` - Sample target program used for testing, simulates a simple program loop

To develop and test core Gernig functionality outside of Python, build via Make:

```
cd gernig
make
```

Build for 32-bit:

```
make m32=1
```

Run on sample program:

```
loader64.exe program64.exe
```

### Module Development

Each noise module is separated into their respective `.cpp` and `.hpp` files located in `gernig/src/modules` and `gernig/include/modules` respectively.

Modules are implemented as thread callback functions passed to `std::thread`, which will be dispatched from `main`.

In the following module function, the `printLoop` function will be launched as a thread and the argument `msg` will be printed to the console every second, alongside the target binary.

```cpp
void printLoop(std::string msg)
{
    while (1)
    {
        std::cout << msg << std::endl;
        Sleep(1000);
    }
}
```

Preprocessor conditional directives are used to "pass information" from Python to C++, such as enabling a certain module or passing a string parameter:

`defines.h`:

```c
#define _PRINT_NOISE_ENABLED
#define _PRINT_NOISE_TEXT "Hello world!"
```

`main.cpp`:

```cpp
#include <defines.h>

#ifdef _PRINT_NOISE_ENABLED
    std::thread t1(printLoop, _PRINT_NOISE_TEXT);
#endif
```

Finally, the original target binary is embedded into the program as an array of `unsigned char` in `binexp.h`, and is parsed and loaded directly from memory via `LoadFromMemory` by calling its entry point stored in `pMemoryModule->exeEntry`.
Further obfuscation can be performed on this array if required.

`binexp.h`:

```c
unsigned char BINARY_ARRAY[] = {
    0x4d, 0x5a, 0x90, 0x00, 0x03,
    ...
}
```

### Available Modules

The following shows the available modules that were implemented, what they are for, and how to use them.

#### `DnsNoise()`

`DnsNoise` is a DNS noise generator feature that queries for randomly generated domain names that are hardcoded into the binary at compile time. 

Domain names are generated by using a dictionary wordlist under `dns\wordlist.txt`, where two words are randomly picked out of the wordlist and concatenated together with a random top level domain using a TLD wordlist under `dns\tld.txt`.

```python
from gernig.noiser import Noiser
from gernig.modules import DnsNoise
n = Noiser("<filename>")
n.addAnalysis(DnsNoise())
n.generate()
```

#### `DnsAnalysis()`

`DnsAnalysis` checks for valid DNS resolvers on the system by ensuring that actual domain names are getting resolved and not all domain names. If it is unable to resolve the DNS names for a quarter or more of the valid DNS names, or a quarter or more of the invalid DNS names are being resolved, then the program exits. The domain names it uses to query are hardcoded into the binary on compile time. 

Domain names are not regenerated by default if the `fake-domains.txt` and `resolved-domains.txt` files exist, as domain names will then be taken from these text files. Domain names can be regenerated at compile time by passing the 'force' parameter to the DnsAnalysis class. Domain names are generated using the same algorithm as the `DnsNoise` class.

Parameter:
- arg: optional argument; pass the string "force" to it to regenerate domain names to be used for this function

```python
from gernig.noiser import Noiser
from gernig.modules import EventlogBlind
n = Noiser("<filename>")
n.addAnalysis(DnsAnalysis('force'))
n.generate()
```

#### `EventlogBlind()`
It kills the Event Logging service using an exploit, rendering any services that rely on the Windows Event Log useless.

```python
from gernig.noiser import Noiser
from gernig.modules import EventlogBlind
n = Noiser("<filename>")
n.addAnalysis(EventlogBlind())
n.generate()
```

#### `MACAddrAnalysis()`
It checks the MAC addresses of the host system to ensure that not all MAC address OUIs belong to virtual machine manufacturers.

```python
from gernig.noiser import Noiser
from gernig.modules import MACAddrAnalysis
n = Noiser("<filename>")
n.addAnalysis(MACAddrAnalysis(['98:76:54', '12:34:56']))
n.generate()
```

#### `CPUIDAnalysis()` 
It checks the CPU ID to ensure that it does not belong to a virtual machine CPU ID, and if the CPU ID belongs to the virtual machine CPU ID, then it terminates the program.

```python
from gernig.noiser import Noiser
from gernig.modules import CPUIDAnalysis
n = Noiser("<filename>")
n.addAnalysis(CPUIDAnalysis())
n.generate()
```

#### `ProcessAnalysis()`
It checks the name of the processes running on the system if there are any blacklisted process names amongst them, and if it finds a blacklisted process name, then it terminates the program.

Parameters:
- process_list: a list of blacklisted process names

```python
from gernig.noiser import Noiser
from gernig.modules import ProcessAnalysis
n = Noiser("<filename>")
n.addAnalysis(ProcessAnalysis(["vmware.exe", "sandbox_process.exe"]))
n.generate()
```

#### `SleepAnalysis()`
It delays the execution of the program while testing if the sleep function is patched by the host system, and aborts execution if the program actual sleep timing is different from the time it was supposed to sleep

Parameters:
- sleep_time: time to delay program execution in milliseconds

```python
from gernig.noiser import Noiser
from gernig.modules import SleepAnalysis
n = Noiser("<filename>")
n.addAnalysis(SleepAnalysis(1000))
n.generate()
```